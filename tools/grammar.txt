Program
  = body:Statements? {
      return {
        type: "Program",
        body: body ?? []
      };
    }

Statements
  = head:Statement tail:(_ @Statement)* {
      return [head].concat(tail)
    }

Statement
  = Declaration

Declaration = InterfaceDeclaration / EnumDeclaration

InterfaceDeclaration
  = extend:("extend" _)? "interface" _ id:Identifier heritage:(_ @InterfaceHeritage)? _ "{" _ body:InterfaceBody? _ "}" {
      return {
        type: "InterfaceDeclaration",
        id,
        body,
        heritage,
        extend: !!extend
      }
    }

EnumDeclaration = extend:("extend" _)? "enum" _ id:Identifier _ "{" _ body:EnumBody  _ "}" {
  return {
    type: "EnumDeclaration",
    id,
    body,
    extend: !!extend
  }
}

Identifier
  = [a-zA-Z_][a-zA-Z0-9_]* {
      return {
        type: "Identifier",
        name: text(),
      }
    }

InterfaceBody = head:Property tail:(_ @Property)* {
  return {
    type: "InterfaceBody",
    properties: [head].concat(tail)
  }
}

InterfaceHeritage = "<:" _ head:Identifier rest:(_ "," _  @Identifier)* {
  return {
    type: "InterfaceHeritage",
    body: [head].concat(rest),
  }
}

EnumBody = head:EnumMember tail:(_ "|" _  @EnumMember)* {
  return {
    type: "EnumBody",
    members: [head].concat(tail),
  }
}

Property
  = key:Identifier _ ":" _ annotation:Annotation _ ";" {
      return {
        type: "Property",
        key,
        annotation
      };
    }

EnumMember = StringLiteral

StringLiteral "string"
  = '"' chars:DoubleStringCharacter* '"' {
      return { type: "StringLiteral", value: chars.join("") };
    }

Annotation = UnionType/ LiteralType / TypeReference / TupleType / TypeLiteral

UnionType = first:UnionMember _ "|" _ second:UnionMember rest:(_ "|" _ @UnionMember)* {
  return {
    type: "UnionType",
    types: [first, second].concat(rest)
  }
}

UnionMember = LiteralType / TypeReference

LiteralType = literal:Literal {
  return {
    type: "LiteralType",
    literal
  }
}

TypeReference = name:Identifier {
  return {
    type: "TypeReference",
    name
  }
}

TupleType = "[" _ element:(UnionType / TypeReference / LiteralType) _ "]" {
  return {
    type: "TupleType",
    element
  }
}

TypeLiteral = "{" _ head:Property tail:(_ @Property)* _ "}" {
  return {
    type: "TypeLiteral",
    members: [head].concat(tail)
  }
}

Literal = StringLiteral / Keyword

Keyword = StringKeyword / NullKeyword / NumberKeyword / BooleanKeyword

StringKeyword = "string" {
  return {
    type: "StringKeyword"
  }
}

NullKeyword = "null" {
  return {
    type: "NullKeyword"
  }
}

NumberKeyword = "number" {
  return {
    type: "NumberKeyword"
  }
}

BooleanKeyword = "boolean" {
  return {
    type: "BooleanKeyword"
  }
}

quotation_mark
  = '"'

Comment "comment"
  = SingleLineComment

SourceCharacter
  = .

DoubleStringCharacter
  = !('"' / "\\" / LineTerminator) SourceCharacter { return text(); }
  / "\\" sequence:EscapeSequence { return sequence; }
  / LineContinuation

EscapeSequence
  = CharacterEscapeSequence
  / "0" !DecimalDigit { return "\0"; }
  / HexEscapeSequence
  / UnicodeEscapeSequence

CharacterEscapeSequence
  = SingleEscapeCharacter
  / NonEscapeCharacter

HexEscapeSequence
  = "x" digits:$(HexDigit HexDigit) {
      return String.fromCharCode(parseInt(digits, 16));
    }

UnicodeEscapeSequence
  = "u" digits:$(HexDigit HexDigit HexDigit HexDigit) {
      return String.fromCharCode(parseInt(digits, 16));
    }

HexDigit
  = [0-9a-f]i

SingleEscapeCharacter
  = "'"
  / '"'
  / "\\"
  / "b"  { return "\b"; }
  / "f"  { return "\f"; }
  / "n"  { return "\n"; }
  / "r"  { return "\r"; }
  / "t"  { return "\t"; }
  / "v"  { return "\v"; }

LineContinuation
  = "\\" LineTerminatorSequence { return ""; }

NonEscapeCharacter
  = !(EscapeCharacter / LineTerminator) SourceCharacter { return text(); }

EscapeCharacter
  = SingleEscapeCharacter
  / DecimalDigit
  / "x"
  / "u"

DecimalDigit
  = [0-9]

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)*

LineTerminator
  = [\n\r\u2028\u2029]

_
  = (WhiteSpace / LineTerminatorSequence / Comment)*

WhiteSpace "whitespace"
  = "\t"
  / "\v"
  / "\f"
  / " "
  / "\u00A0"
  / "\uFEFF"
  / Zs

// Separator, Space
Zs = [\u0020\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028"
  / "\u2029"
